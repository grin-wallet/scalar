cmake_minimum_required(VERSION 3.8)

#
# Here we check whether mio is being configured in isolation or as a component
# of a larger project. To do so, we query whether the `PROJECT_NAME` CMake
# variable has been defined. In the case it has, we can conclude mio is a
# subproject.
#
# This convention has been borrowed from the Catch C++ unit testing library.
#
if(DEFINED PROJECT_NAME)
  set(subproject ON)
else()
  set(subproject OFF)
endif()

project(mio VERSION 1.0.0 LANGUAGES C CXX)
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
include (CTest)
include (CMakeDependentOption)

# Generate 'compile_commands.json' for clang_complete
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

#
# The `mio.testing` options only appear as cmake-gui and ccmake options iff
# mio is the highest level project. In the case that mio is a subproject, these
# options are hidden from the user interface and set to `OFF`
#
# Iff mio is the highest level project, this option is defaulted to the value
# of the traditional course grain testing option `BUILD_TESTING` established by
# the CTest module
#
CMAKE_DEPENDENT_OPTION(mio.tests
  "Build the mio tests and integrate with ctest"
  ${BUILD_TESTING} "NOT subproject" OFF)

#
# mio has no compiled components. As such, we declare it as an `INTERFACE`
# library, which denotes a collection of target properties to be applied
# transitively to linking targets. In our case, this amounts to an include
# directory and project header files.
#
add_library(mio_base INTERFACE)

#
# mio requires C++ 11 support, at a minimum. Setting the `cxx_std_11` compile
# features ensures that the corresponding C++ standard flag is populated in
# targets linking to mio
#
target_compile_features(mio_base INTERFACE cxx_std_11)

# 
# On Windows, so as to be a "good citizen", mio offers two different 
# targets that control the imported surface area of the Windows API. The 
# default `mio` target sets the necessary flags for a minimal Win API 
# (`WIN32_LEAN_AND_MEAN`, etc.), while the `mio_full_winapi` target sets 
# none of these flags so will not disable any of the modules.
# 
if(WIN32)
    include(WinApiLevels)
else()
    # On non-Windows systems, the `mio` and `mio_base` targets are 
    # effectively identical.
    add_library(mio INTERFACE)
    target_link_libraries(mio
        INTERFACE mio_base
    )
endif()

add_library(mio::mio ALIAS mio)

#
# The include directory for mio can be expected to vary between build
# and installaion. Here we use a CMake generator expression to dispatch
# on how the configuration under which this library is being consumed.
#
target_include_directories(mio_base INTERFACE
  $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>
  $<INSTALL_INTERFACE:include>)

add_subdirectory(include/mio)

if(mio.tests)
  add_subdirectory(test)
endif()

#
# Non-testing header files (preserving relative paths) are installed to the
# `include` subdirectory of the `$INSTALL_DIR/${CMAKE_INSTALL_PREFIX}`
# directory. Source file permissions preserved.
#
install(DIRECTORY include/
  DESTINATION include
  USE_SOURCE_PERMISSIONS
  FILES_MATCHING PATTERN "*.*pp")

#
# As a header-only library, there are no target components to be installed
# directly (the PUBLIC_HEADER property is not white listed for INTERFACE
# targets for some reason).
#
# However, it is worthwhile export our target description in order to later
# generate a CMake configuration file for consumption by CMake's `find_package`
# intrinsic
#
install(TARGETS mio_base mio EXPORT mioConfig)
install(EXPORT mioConfig
  FILE mioConfig.cmake
  NAMESPACE mio::
  DESTINATION share/cmake/mio
  PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)

include(CMakePackageConfigHelpers) # provides `write_basic_package_version_file`
write_basic_package_version_file("mioConfigVersion.cmake"
  VERSION ${mio_VERSION}
  COMPATIBILITY SameMajorVersion)

install(FILES "${CMAKE_CURRENT_BINARY_DIR}/mioConfigVersion.cmake"
  DESTINATION share/cmake/mio
  PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)

#
# Rudimentary CPack support.
#
# CPack provides a mechanism to generate installation packaging for a project,
# e.g., self-extracting shell scripts, compressed tarballs, Debian Package files,
# RPM Package Manager files, Windows NSIS installation wizards,
# Apple Disk Images (.dmg), etc.
#
# Any system libraries required (runtimes, threading, etc) should be bundled
# with the project for this type of installation. The
# `InstallRequiredSystemLibraries` CMake module attempts to provide this
# functionality in an automated way. Additional libraries may be specified as
#
# ```cmake
# list(APPEND CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS <library>)
# ```
#
# A packaged installation can be generated by calling
#
# ```sh
# cpack -G <packaging type> --config CPackConfig.cmake
# ```
#
# See `cpack --help` or the CPack documentation for more information.
#
include( InstallRequiredSystemLibraries )
set( CPACK_PACKAGE_VENDOR "mandreyel" )
set( CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE" )
set( CMAKE_PROJECT_HOMEPAGE_URL "https://github.com/mandreyel/mio" )
include( CPack )
